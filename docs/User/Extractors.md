# Extractors
An extractor provides additional context to a read connector in order to provide support for read operations that span multiple requests. Context is provided in the form of one or more extract parameters that are either generated by the extractor or by a user-defined function.

To use an extractor in a pipeline, include it directly after the read connector declaration. If no extractor is specified, then the default extractor (an extract parameter forwarder) is used.

| :information_source: Rowbot Convention |
| --- |
| <p>Extension methods for extractors should always use <strong>With</strong> as a prefix. This differentiates them from read connectors which should use <strong>Extract</strong> as a prefix.</p> |

Rowbot includes two built-in extractors. Both provide support for pagination.

## Offset Pagination Extractor
Offset pagination iterates through data pages by increasing or decreasing an offset value.

The offset pagination extractor `.WithOffsetPagination()` generates the offset value and provides it to the read connector as the parameter `@Offset`. The extractor continues iterating through pages until no data is returned.

```csharp
public Pipeline Load() =>
    _pipelineBuilder
        .ExtractSqlite<SourceCustomer>(
            sourceConnectionString,
            @"SELECT [Id], [Name]
            FROM [SourceCustomer]
            LIMIT 100 OFFSET @Offset")
        .WithOffsetPagination()
        .Transform<Customer>(...)
        .LoadSqlite(targetConnectionString)
        .WithSlowlyChangingDimension();
```

## Cursor Pagination Extractor
Cursor pagination iterates through data pages by keeping track of the value of a cursor field.

The cursor pagination extractor `.WithCursorPagination()` requires a cursor be provided as an argument. It keeps track of the last value of the cursor from the previous page and provides that to the read connector as a parameter. The extractor continues iterating through pages until no data is returned.

> The cursor parameter has the same name as the property from the entity class.

```csharp
public Pipeline Load() =>
    _pipelineBuilder
        .ExtractSqlite<SourceCustomer>(
            sourceConnectionString,
            @"SELECT [Id], [Name]
            FROM [SourceCustomer]
            WHERE [Id] > @Id
            LIMIT 100")
        .WithCursorPagination(x => x.Id)
        .Transform<Customer>(...)
        .LoadSqlite(targetConnectionString)
        .WithSlowlyChangingDimension();
```

## Extract Parameters
An extractor provides additional context to a read connector using extract parameters. An extract parameter is an object of type `ExtractParameter` and is essentially a key-value pair. A collection of `ExtractParameter` objects can be wrapped in an `ExtractParameterCollection`.

If an extractor generates, or is provided with, a collection of one or more `ExtractParameterCollection` objects, it will iterate over them and provide each in a separate invocation of the read connector's query method.

> All extractors accept user-generated extract parameters but they are not guaranteed to forward them. It is the responsibility of the extractor developer to decide whether to provide support for user-generated extract parameters, and if so, how to utilise them.

### Inject Extract Parameters
Users can generate extract parameters and inject them into an extractor to be forwarded on to the read connector.

Pipeline builder supports adding one or more extract parameters by including extractor options with the `IncludeOptions()` extension method and then using `AddParameter()` or `AddParameters`.

```csharp
public Pipeline Load() =>
    _pipelineBuilder
        .ExtractHttp<SourceCustomer>()
        .IncludeOptions(options => options.AddParameter("AccessToken", GetAccessToken())
        .Transform<Customer>(...)
        .LoadSqlite(targetConnectionString)
        .WithSlowlyChangingDimension();
```

#### Deferred Execution
In the following example, a method named `GetAccessTokensAsync()` generates access tokens which are subsequently provided to the HTTP read connector.

Let's imagine in this example that different groups of customers are isolated by security boundary and require separate access tokens. `GetAccessTokensAsync()` generates an `ExtractParameterCollection` for every group of customers and returns an `IEnumerable<ExtractParameterCollection>`.

`AddExtractParameters()` accepts this as a func delegate of type `Func<Task<IEnumerable<ExtractParameterCollection>>>` so that execution is deferred until the pipeline is executed by pipeline runner. 

During pipeline execution, `GetAccessTokensAsync()` is invoked and generates a list of access tokens. The extractor iterates over the collection and ensures that the HTTP read connector queries the endpoint for every group of customers, each time providing a different access token.

```csharp
public Pipeline Load() =>
    _pipelineBuilder
        .ExtractHttp<SourceCustomer>()
        .IncludeOptions(options => options.AddParameters(async () => await GetAccessTokensAsync())
        .Transform<Customer>(...)
        .LoadSqlite(targetConnectionString)
        .WithSlowlyChangingDimension();
```